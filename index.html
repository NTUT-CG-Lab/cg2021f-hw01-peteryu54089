<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - loader - ttf</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body style="background-color:black!important;">
		<div style="position:-webkit-sticky;position:sticky;top:0;"></div>
		<script src="./scoreoutputer.min.js"></script>
		<script src="./opentype.min.js"></script>
		<script src="./three.min.js"></script>
		<script src="./TTFLoader.js"></script>
		<script src="./PLYLoader.js"></script>
		<script>
			window.scrollTo(0, document.body.scrollHeight);

			setInterval(function() {
				window.scrollTo(0, document.body.scrollHeight);
			}, 5000);

			window.addEventListener('scroll', function() {
				window.scrollTo(0, document.body.scrollHeight);
			});

			// SCORE OUTPUTER

			let so = new ScoreOutputer('109598035');

			so.installCSS(function() {
				so.addChild('創建場景', 2, true);
				so.addChild('讀取字型檔', 2, true);
				so.addChild('將地支以圓圈排列', 2, true);
				so.addChild('滑鼠點擊 12 地支分別跳轉網頁', 1, true);
				so.addChild('顯示 \"高等計算機圖形作業\"', 1, true);
				so.addChild('時鐘效果', 1, true);
				so.addChild('任何 ply 格式模型', 1, true);

				// 產生自評表，參數如下所示
				so.renderModal(
					// 1. 自評表插入位置 (預設 document.body)
					document.body,
					// 2. 自評表背景 (預設紅色)
					'rgba(100,45,58,1)', 
					// 3. 自評表文字顏色 (預設白色)
					'white', 
					// 4. 自評表文字大小 (預設 14pt)
					'15pt', 
					// 5. 自評表 checkbox 文字大小 (預設多少忘了)
					'15px', 
					// 6. 自評表標題 (預設 "自我評分表")
					dialogTitle='自我評分表'
				);

				// 設定下載按鈕 (一定要呼叫這個函數，不然沒有下載功能)
				so.installDownloadBtn();

				// 產生 '開啟自評表按鈕'
				so.renderBtn(
					// 自評表按鈕插入位置
					document.body.childNodes[1],
					// 自評表按鈕文字
					'開啟自評表'
				);
			});

			// CANVAS

			let container;
			let camera, cameraTarget, scene, renderer;
			let group, textMesh1, textMesh2, textGeo, material, ply, flag = 0;
			let firstLetter = true;

			let text = 'three.js';
			let texts = ['子', '丑', '寅', '卯', '辰', '巳', '午', '未', '申', '酉', '戌', '亥'];
			let times = ['12', '01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11'];
			let positionX = [0, 50, 86.6, 100, 86.6, 50, 0, -50, -86.6, -100, -86.6, -50];
			let positionY = [200, 186.6, 150, 100, 50, 13.4, 0, 13.4, 50, 100, 150, 186.6];
			const height = 20, size = 15, hover = 30, curveSegments = 4, bevelThickness = 2, bevelSize = 1.5;

			let font = null;
			const mirror = false;

			let targetRotation = 0;
			let targetRotationOnPointerDown = 0;

			let pointerX = 0;
			let pointerXOnPointerDown = 0;

			let windowHalfX = window.innerWidth / 2;

			// RAYCASTER

			const raycaster = new THREE.Raycaster();
			const mouse = new THREE.Vector2();

			// CLOCK

			let hands = createHands();

			// RENDER

			init();
			animate();

			function init() {
				container = document.createElement('div');
				document.body.appendChild(container);

				// CAMERA

				camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 1500);
				camera.position.set(0, 400, 700);
				cameraTarget = new THREE.Vector3(0, 200, 0);

				// SCENE

				scene = new THREE.Scene();
				scene.background = new THREE.Color(0x000000);
				scene.fog = new THREE.Fog(0x000000, 250, 1400);

				// LIGHTS

				const dirLight = new THREE.DirectionalLight(0xffffff, 0.125);
				dirLight.position.set(0, 0, 1).normalize();
				scene.add(dirLight);

				const pointLight = new THREE.PointLight(0xffffff, 1.5);
				pointLight.position.set(0, 100, 90);
				// pointLight.color.setHSL(Math.random(), 1, 0.5);
				scene.add(pointLight);

				material = new THREE.MeshPhongMaterial({color: 0xffffff, flatShading: true});

				group = new THREE.Group();
				group.position.y = 100;
				scene.add(group);

				// TEXT

				let loader = new THREE.TTFLoader();

				loader.load('fonts/ttf/edukai-4.0.ttf', function(json) {
					console.log(json);
					font = new THREE.Font(json);
					for (i = 0; i < texts.length; i++) {
						createTexts(texts[i], positionX[i], positionY[i]);
					}
					createText();
				});

				// PLANE

				const plane = new THREE.Mesh(new THREE.PlaneGeometry(500, 500), new THREE.MeshBasicMaterial({color: 0xffffff, opacity: 0.5}));
				plane.rotation.x = - Math.PI / 2;
				group.add(plane);

				// CLOCK

				group.add(hands.group);

				// PLY

				loader = new THREE.PLYLoader();

				loader.load('hand.ply', function(geometry) {
					geometry.computeVertexNormals();
					ply = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({color: 0xffdac8, flatShading: true}));
					ply.rotation.x = Math.PI * 2;
					ply.position.y = 70;
					ply.position.z = -100;
					group.add(ply);
				});

				// RENDERER

				renderer = new THREE.WebGLRenderer({antialias: true});
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				container.appendChild(renderer.domElement);

				// EVENTS

				container.style.touchAction = 'none';
				container.addEventListener('pointerdown', onPointerDown);

				// document.addEventListener('keypress', onDocumentKeyPress);
				// document.addEventListener('keydown', onDocumentKeyDown);

				window.addEventListener('resize', onWindowResize);
				window.addEventListener('click', onClick);
				window.addEventListener('mousemove', onMouseMove, false);
			}

			function onWindowResize() {
				windowHalfX = window.innerWidth / 2;
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function onDocumentKeyDown(event) {
				if (firstLetter) {
					firstLetter = false;
					text = '';
				}
				const keyCode = event.keyCode;
				// backspace
				if (keyCode === 8) {
					event.preventDefault();
					text = text.substring(0, text.length - 1);
					refreshText();
					return false;
				}
			}

			function onDocumentKeyPress(event) {
				const keyCode = event.which;
				// backspace
				if (keyCode === 8) {
					event.preventDefault();
				} else {
					const ch = String.fromCharCode(keyCode);
					text += ch;
					refreshText();
				}
			}

			function createText() {
				textGeo = new THREE.TextGeometry('高等計算機圖學作業', {
					font: font,
					size: 25,
					height: height,
					curveSegments: curveSegments,
					bevelThickness: bevelThickness,
					bevelSize: bevelSize,
					bevelEnabled: true
				});
				textGeo.computeBoundingBox();
				textGeo.computeVertexNormals();
				const centerOffset = - 0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
				textMesh1 = new THREE.Mesh(textGeo, material);
				textMesh1.position.x = centerOffset;
				textMesh1.position.y = - 15;
				textMesh1.position.z = 150;
				textMesh1.rotation.x = Math.PI * 3.5;
				group.add(textMesh1);
			}

			function createTexts(t, x, y) {
				textGeo = new THREE.TextGeometry(t, {
					font: font,
					size: size,
					height: height,
					curveSegments: curveSegments,
					bevelThickness: bevelThickness,
					bevelSize: bevelSize,
					bevelEnabled: true
				});
				textGeo.computeBoundingBox();
				textGeo.computeVertexNormals();
				const centerOffset = - 0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
				textMesh1 = new THREE.Mesh(textGeo, material);
				textMesh1.userData.url = 'https://ntut-cg-lab.github.io/cg2021f-hw' + times[i] + '-peteryu54089/';
				textMesh1.position.x = centerOffset + x;
				textMesh1.position.y = hover + y;
				textMesh1.position.z = 0;
				textMesh1.rotation.x = 0;
				textMesh1.rotation.y = Math.PI * 2;
				group.add(textMesh1);
				if (mirror) {
					textMesh2 = new THREE.Mesh(textGeo, material);
					textMesh2.position.x = centerOffset + x;
					textMesh2.position.y = - (hover + y);
					textMesh2.position.z = height;
					textMesh2.rotation.x = Math.PI;
					textMesh2.rotation.y = Math.PI * 2;
					group.add(textMesh2);
				}
			}

			function refreshText() {
				group.remove(textMesh1);
				if (mirror) group.remove(textMesh2);
				if (!text) return;
				createText();
			}

			function onPointerDown(event) {
				if (event.isPrimary === false) return;
				pointerXOnPointerDown = event.clientX - windowHalfX;
				targetRotationOnPointerDown = targetRotation;
				document.addEventListener('pointermove', onPointerMove);
				document.addEventListener('pointerup', onPointerUp);
			}

			function onPointerMove(event) {
				if (event.isPrimary === false) return;
				pointerX = event.clientX - windowHalfX;
				targetRotation = targetRotationOnPointerDown + (pointerX - pointerXOnPointerDown) * 0.02;
			}

			function onPointerUp() {
				if (event.isPrimary === false) return;
				document.removeEventListener('pointermove', onPointerMove);
				document.removeEventListener('pointerup', onPointerUp);
			}

			// LOOP

			function animate() {
				hands.update();
				requestAnimationFrame(animate);
				onHover();
				if (ply !== undefined) {
					ply.rotation.y += 0.01;
					if (flag === 0) ply.position.z += 1;
					else ply.position.z -= 1;
					if (ply.position.z === 230) flag = 1;
					else if (ply.position.z === -230) flag = 0;
				}
				group.rotation.y += (targetRotation - group.rotation.y) * 0.05;
				camera.lookAt(cameraTarget);
				renderer.render(scene, camera);
			}

			// RAYCASTER

			function onMouseMove(event) {
				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
			}

			function onHover() {
				raycaster.setFromCamera(mouse, camera);
				const intersects = raycaster.intersectObjects(scene.children, true);
				if (intersects.length > 0 && intersects[0].object.userData.url !== undefined) {
					document.body.style.cursor = 'pointer';
				} else {
					document.body.style.cursor = 'default';
				}
			}

			function onClick() {
				raycaster.setFromCamera(mouse, camera);
				const intersects = raycaster.intersectObjects(scene.children, true);
				if (intersects.length > 0 && intersects[0].object.userData.url !== undefined) {
					window.open(intersects[0].object.userData.url);
				}
			}

			// CLOCK

			function createCylinder() {
				let cylinder = new THREE.Mesh(new THREE.CylinderGeometry(15, 15, 10, 50, 50), new THREE.MeshBasicMaterial({color: 0x87cefa}));
				cylinder.rotation.x = Math.PI * 0.5;
				return cylinder;
			}

			function setClockTime() {
				let clock = {};
				clock.now = new Date();
				clock.timeText = clock.now.getTime();
				clock.secPer = clock.now.getMilliseconds() / 1000;
				clock.minPer = clock.now.getSeconds() / 60;
				clock.hourPer = clock.now.getMinutes() / 60;
				let dayStart = new Date(clock.now.getFullYear(), clock.now.getMonth(), clock.now.getDate(), 0, 0, 0, 0);
				clock.dayPer = (clock.now - dayStart) / 86400000;
				return clock;
			};

			function createHandPoints(cx, cy, cz, cr) {
				return 'sec,min,hour'.split(',').map(function(timeUnit, i) {
					let per = setClockTime()[timeUnit + 'Per'] || 0;
					let rad = Math.PI * 2 * per * -1 + Math.PI / 2;
					return [Math.cos(rad) * (cr - (i * 2 + 2)) + cx, Math.sin(rad) * (cr - (i * 2 + 2)) + cy, cz];
				});
			};

			function createHands() {
				let group = new THREE.Group();
				group.add(createCylinder(), createCylinder(), createCylinder());
				let update = function() {
					createHandPoints(0, 0, 0, 105).forEach(function(points, i) {
						group.children[i].position.set(points[0], points[1] + 135, points[2] + 10);
					});
				};
				update();
				return {
					group: group,
					update: update
				};
			};
		</script>
	</body>
</html>
